var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/is-object.ts
var isObject = /* @__PURE__ */ __name((obj) => Object.prototype.toString.call(obj) === "[object Object]", "isObject");

// src/shallow-copy.ts
var DO_NOT_SHALLOW_COPY = Symbol();
var doNotShallowCopy = /* @__PURE__ */ __name((obj) => {
  Object.defineProperty(obj, DO_NOT_SHALLOW_COPY, {
    configurable: true,
    enumerable: false,
    writable: false,
    value: true
  });
  return obj;
}, "doNotShallowCopy");
var shallowCopy = /* @__PURE__ */ __name((obj) => {
  if (Reflect.has(obj, DO_NOT_SHALLOW_COPY)) {
    return obj;
  }
  if (isObject(obj)) {
    return { ...obj };
  } else if (Array.isArray(obj)) {
    return [...obj];
  } else {
    throw new Error("shallowCopy expected a plain object or array");
  }
}, "shallowCopy");

// src/basic-lens.ts
var identity = Object.freeze({
  get(s) {
    return s;
  },
  set(s, a) {
    return a;
  }
});
var basicLens = /* @__PURE__ */ __name(() => identity, "basicLens");
var refine = /* @__PURE__ */ __name((lens, get, set) => {
  return {
    get(s) {
      const a = lens.get(s);
      return get(a);
    },
    set(s, b) {
      const a = lens.get(s);
      return lens.set(s, set(a, b));
    }
  };
}, "refine");
var prop = /* @__PURE__ */ __name((lens, key) => {
  return refine(lens, (s) => s[key], (a, ak) => {
    const copy = shallowCopy(a);
    copy[key] = ak;
    return copy;
  });
}, "prop");

// src/lens-focus.ts
function refineLensFocus(focus, keys) {
  const keyPath = [...focus.keyPath, ...keys];
  let lens = focus.lens;
  for (const key of keys) {
    lens = prop(lens, key);
  }
  return { keyPath, lens };
}
__name(refineLensFocus, "refineLensFocus");
var rootLensFocus = /* @__PURE__ */ __name(() => {
  return {
    keyPath: [],
    lens: basicLens()
  };
}, "rootLensFocus");

// src/breaker.ts
var Breaker = class {
  constructor(subscribe) {
    this.subscribe = subscribe;
    __publicField(this, "state", { connected: false });
  }
  static noop() {
    return new Breaker(() => () => {
    });
  }
  get connected() {
    return this.state.connected;
  }
  connect() {
    if (this.state.connected) {
      return;
    }
    const unsubscribe = this.subscribe.call(null);
    this.state = {
      connected: true,
      unsubscribe
    };
  }
  disconnect() {
    if (!this.state.connected) {
      return;
    }
    this.state.unsubscribe();
    this.state = {
      connected: false
    };
  }
};
__name(Breaker, "Breaker");

// src/suspended-closure.ts
var SuspendedClosure = class {
  constructor() {
    __publicField(this, "resolution", { status: "unresolved" });
    __publicField(this, "breaker", Breaker.noop());
    __publicField(this, "onReady");
    __publicField(this, "ready");
    let ready = /* @__PURE__ */ __name(() => {
    }, "ready");
    this.onReady = new Promise((resolve) => {
      ready = resolve;
    });
    this.ready = () => ready();
  }
  getSnapshot() {
    if (this.resolution.status !== "resolved") {
      throw this.onReady;
    }
    return this.resolution.value;
  }
  setSnapshot(value) {
    switch (this.resolution.status) {
      case "unresolved": {
        return;
      }
      case "loading": {
        this.resolution = { status: "resolved", value };
        this.ready();
        return;
      }
      case "resolved": {
        this.resolution.value = value;
        return;
      }
    }
  }
  load(subscribe) {
    if (this.resolution.status !== "unresolved") {
      return;
    }
    this.resolution = { status: "loading" };
    const isAlreadyConnected = this.breaker.connected;
    this.breaker = new Breaker(subscribe);
    if (isAlreadyConnected) {
      this.breaker.connect();
    }
  }
  connect() {
    this.breaker.connect();
  }
  disconnect() {
    this.breaker.disconnect();
  }
};
__name(SuspendedClosure, "SuspendedClosure");

// src/connection.ts
var INSERT = Symbol();
var CACHE = Symbol();
var connection = /* @__PURE__ */ __name((create) => {
  const connectionCache = {};
  const stub = doNotShallowCopy({});
  const cache2 = new Proxy(stub, {
    get(_target, _key) {
      let key = _key;
      let cached = connectionCache[key] ?? (connectionCache[key] = new SuspendedClosure());
      return cached.getSnapshot();
    },
    set(_target, _key, value) {
      let key = _key;
      let conn2 = connectionCache[key];
      if (conn2 === void 0) {
        return false;
      }
      conn2.setSnapshot(value);
      return true;
    }
  });
  const insert2 = /* @__PURE__ */ __name((store, input, cacheKey) => {
    let conn2 = connectionCache[cacheKey] ?? (connectionCache[cacheKey] = new SuspendedClosure());
    conn2.load(() => create(store, input) ?? (() => {
    }));
    return conn2;
  }, "insert");
  const conn = doNotShallowCopy({});
  Object.defineProperties(conn, {
    [INSERT]: {
      configurable: true,
      enumerable: false,
      writable: false,
      value: insert2
    },
    [CACHE]: {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cache2
    }
  });
  return conn;
}, "connection");
var focusToCache = /* @__PURE__ */ __name((focus, cacheKey) => refineLensFocus(focus, [CACHE, cacheKey]), "focusToCache");
var insert = /* @__PURE__ */ __name((conn, store, input, cacheKey) => {
  return conn[INSERT](store, input, cacheKey);
}, "insert");
var isConnection = /* @__PURE__ */ __name((conn) => {
  return isObject(conn) && Reflect.has(conn, INSERT) && Reflect.has(conn, CACHE);
}, "isConnection");

// src/key-path-to-string.ts
var cache = /* @__PURE__ */ new WeakMap();
var IS_NUMBER_STRING = /^\d+$/;
var keyPathToString = /* @__PURE__ */ __name((keyPath) => {
  let cached = cache.get(keyPath);
  if (!cached) {
    cached = "root";
    for (let key of keyPath) {
      if (typeof key === "symbol" || typeof key === "number" || key.match(IS_NUMBER_STRING)) {
        cached += `[${String(key)}]`;
      } else {
        cached += `.${key}`;
      }
    }
    cache.set(keyPath, cached);
  }
  return cached;
}, "keyPathToString");

// src/react.ts
import React from "react";

// src/proxy-value.ts
var isProxyable = /* @__PURE__ */ __name((obj) => Array.isArray(obj) || isObject(obj), "isProxyable");
var proxyHandler = {
  get(target, key) {
    if (key === "toJSON") {
      target.toJSON ?? (target.toJSON = () => target.data);
      return target.toJSON;
    }
    if (key === "toLens") {
      target.toLens ?? (target.toLens = () => target.lens);
      return target.toLens;
    }
    const nextData = target.data[key];
    const nextLens = target.lens[key];
    return proxyValue(nextData, nextLens);
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.data).concat(["toLens", "toJSON"]);
  },
  getOwnPropertyDescriptor(target, key) {
    if (key === "toLens" || key === "toJSON") {
      return {
        configurable: true,
        enumerable: true,
        writable: false,
        value: target[key]
      };
    }
    const desc = Object.getOwnPropertyDescriptor(target.data, key);
    if (desc === void 0) {
      return;
    }
    return {
      writable: desc.writable,
      enumerable: desc.enumerable,
      configurable: desc.configurable,
      value: target.data[key]
    };
  },
  has(target, key) {
    return key in target.data;
  },
  getPrototypeOf() {
    return null;
  },
  preventExtensions() {
    return true;
  },
  isExtensible() {
    return false;
  },
  set() {
    throw new Error("Cannot set property on ProxyValue");
  },
  deleteProperty() {
    throw new Error("Cannot delete property on ProxyValue");
  }
};
var valueCache = /* @__PURE__ */ new WeakMap();
var proxyValue = /* @__PURE__ */ __name((data, lens) => {
  if (!isProxyable(data)) {
    return data;
  }
  let cached = valueCache.get(data);
  if (!cached) {
    cached = new Proxy({ data, lens }, proxyHandler);
    valueCache.set(data, cached);
  }
  return cached;
}, "proxyValue");

// src/should-update.ts
var shouldUpdateToFunction = /* @__PURE__ */ __name((shouldUpdate) => {
  if (typeof shouldUpdate === "boolean") {
    return (prev, next) => shouldUpdate ? prev !== next : false;
  }
  if (typeof shouldUpdate === "function") {
    return shouldUpdate;
  }
  if (Array.isArray(shouldUpdate)) {
    const obj = Object.fromEntries(shouldUpdate.map((key) => [key, true]));
    return shouldUpdateToFunction(obj);
  }
  return (prev, next) => {
    let prevIsArr = false;
    let nextIsArr = false;
    let prevArr;
    let nextArr;
    if (Array.isArray(prev)) {
      prevIsArr = true;
      prevArr = prev;
    } else {
      prevArr = [prev];
    }
    if (Array.isArray(next)) {
      nextIsArr = true;
      nextArr = next;
    } else {
      nextArr = [next];
    }
    if (nextIsArr !== prevIsArr) {
      return true;
    }
    if (prevArr.length !== nextArr.length) {
      return true;
    }
    for (let i = 0; i < prevArr.length; i++) {
      const prevValue = prevArr[i];
      const nextValue = nextArr[i];
      for (const key in shouldUpdate) {
        const func = shouldUpdateToFunction(shouldUpdate[key]);
        if (func(prevValue[key], nextValue[key])) {
          return true;
        }
      }
    }
    return false;
  };
}, "shouldUpdateToFunction");

// src/react.ts
var NOTHING = Symbol();
var SHOULD_ALWAYS_RETURN_NEXT = /* @__PURE__ */ __name(() => true, "SHOULD_ALWAYS_RETURN_NEXT");
var createUseLens = /* @__PURE__ */ __name((proxy) => /* @__PURE__ */ __name(function useLens(shouldUpdate = SHOULD_ALWAYS_RETURN_NEXT) {
  React.useDebugValue(proxy.$key);
  const store = React.useMemo(() => proxy.getStore(), [proxy]);
  const shouldUpdateFn = React.useMemo(() => shouldUpdateToFunction(shouldUpdate), [shouldUpdate]);
  const prevStateRef = React.useRef(NOTHING);
  const getSnapshot = /* @__PURE__ */ __name(() => {
    const prev = prevStateRef.current;
    const next = store.getSnapshot();
    if (Object.is(prev, next)) {
      return prev;
    }
    if (prev === NOTHING) {
      return next;
    }
    if (shouldUpdateFn(prev, next)) {
      return next;
    } else {
      return prev;
    }
  }, "getSnapshot");
  const subscribe = React.useMemo(() => {
    let listeners = [];
    const unsubscribe = store.subscribe(() => {
      listeners.forEach((fn) => fn());
    });
    return (listener) => {
      listeners.push(listener);
      return () => {
        unsubscribe();
        listeners = [];
      };
    };
  }, [store]);
  const state = React.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
  const update = React.useCallback((updater) => {
    const prev = store.getSnapshot();
    const next = updater(prev);
    if (Object.is(prev, next)) {
      return;
    }
    store.setSnapshot(next);
  }, [store]);
  prevStateRef.current = state;
  const value = React.useMemo(() => proxyValue(state, proxy), [state, proxy]);
  return [value, update];
}, "useLens"), "createUseLens");
function useCreateLens(initialState) {
  return React.useMemo(() => {
    if (typeof initialState === "function") {
      return createLens(initialState());
    } else {
      return createLens(initialState);
    }
  }, []);
}
__name(useCreateLens, "useCreateLens");

// src/react-devtools.ts
var ReactDevtools = {
  isCalledInsideReactDevtools: () => {
    const err = new Error();
    return err.stack?.includes("react_devtools_backend");
  }
};

// src/awaitable.ts
var isPromiseLike = /* @__PURE__ */ __name((obj) => {
  return isObject(obj) && Reflect.has(obj, "then");
}, "isPromiseLike");
var awaitable = /* @__PURE__ */ __name((get) => () => {
  return {
    then(onfulfilled) {
      const value = get();
      onfulfilled ?? (onfulfilled = null);
      if (onfulfilled === null) {
        throw new Error("Unexpected error. Do not use awaitable(value).then()");
      }
      if (isPromiseLike(value)) {
        return value.then(onfulfilled);
      }
      const result = onfulfilled(value);
      if (isPromiseLike(result)) {
        return result;
      }
      return awaitable(() => result)();
    }
  };
}, "awaitable");

// src/subscription-graph.ts
var id = keyPathToString;
var SubscriptionNode = class {
  constructor(keyPath) {
    this.keyPath = keyPath;
    __publicField(this, "listeners", /* @__PURE__ */ new Set());
    __publicField(this, "id");
    __publicField(this, "ancestor");
    this.id = id(keyPath);
    if (keyPath.length === 0) {
      this.ancestor = { none: true };
    } else {
      this.ancestor = { none: false, keyPath: this.keyPath.slice(0, -1) };
    }
  }
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  notify() {
    this.listeners.forEach((fn) => fn());
  }
  get size() {
    return this.listeners.size;
  }
};
__name(SubscriptionNode, "SubscriptionNode");
var SubscriptionGraph = class {
  constructor() {
    __publicField(this, "nodes", /* @__PURE__ */ new Map());
    __publicField(this, "parents", /* @__PURE__ */ new Map());
    __publicField(this, "children", /* @__PURE__ */ new Map());
  }
  notify(keyPath) {
    const nodeId = id(keyPath);
    const node = this.nodes.get(nodeId);
    if (node) {
      this.notifyAncestors(node);
      this.notifySelfAndChildren(node);
    }
  }
  subscribe(keyPath, listener) {
    const node = this.addNode(keyPath);
    const unsubscribe = node.subscribe(listener);
    return () => {
      unsubscribe();
      this.clean(node);
    };
  }
  get size() {
    return this.nodes.size;
  }
  addNode(keyPath) {
    const nodeId = id(keyPath);
    let node = this.nodes.get(nodeId);
    if (node) {
      return node;
    }
    node = new SubscriptionNode(keyPath);
    this.nodes.set(node.id, node);
    this.children.set(node.id, /* @__PURE__ */ new Set());
    if (node.ancestor.none) {
      return node;
    }
    const parent = this.addNode(node.ancestor.keyPath);
    this.parents.set(node.id, parent);
    const siblings = this.children.get(parent.id);
    if (siblings === void 0) {
      throw new Error("Unexpected Error");
    }
    siblings.add(node);
    return node;
  }
  notifyAncestors(node) {
    const ancestor = this.parents.get(node.id);
    if (ancestor) {
      this.notifyAncestors(ancestor);
      ancestor.notify();
    }
  }
  notifySelfAndChildren(node) {
    node.notify();
    const children = this.children.get(node.id) ?? /* @__PURE__ */ new Set();
    for (const child of children) {
      this.notifySelfAndChildren(child);
    }
  }
  clean(node) {
    const children = this.children.get(node.id) ?? /* @__PURE__ */ new Set();
    if (children.size > 0 || node.size > 0) {
      return;
    }
    this.nodes.delete(node.id);
    this.children.delete(node.id);
    const parent = this.parents.get(node.id);
    if (parent) {
      this.parents.delete(node.id);
      const siblings = this.children.get(parent.id) ?? /* @__PURE__ */ new Set();
      siblings.delete(node);
      this.clean(parent);
    }
  }
};
__name(SubscriptionGraph, "SubscriptionGraph");

// src/store.ts
var noop = /* @__PURE__ */ __name(() => {
}, "noop");
var createRootStoreFactory = /* @__PURE__ */ __name((initialState) => {
  const graph = new SubscriptionGraph();
  const focus = rootLensFocus();
  let snapshot = initialState;
  const factory = /* @__PURE__ */ __name(({ keyPath, lens }) => {
    return {
      getSnapshot() {
        return lens.get(snapshot);
      },
      subscribe(listener = noop) {
        return graph.subscribe(keyPath, listener);
      },
      setSnapshot(next) {
        snapshot = lens.set(snapshot, next);
        graph.notify(keyPath);
        return true;
      }
    };
  }, "factory");
  return [factory, focus];
}, "createRootStoreFactory");
var noopBreakable = { connect() {
}, disconnect() {
} };
var createConnectionStoreFactory = /* @__PURE__ */ __name((storeFactory, connFocus, input) => {
  const cacheKey = `connection([${keyPathToString(connFocus.keyPath)}], ${JSON.stringify(input ?? {})})`;
  const cacheKeyFocus = focusToCache(connFocus, cacheKey);
  const rootStore = storeFactory(connFocus);
  const cacheEntryStore = storeFactory(cacheKeyFocus);
  const getBreakable = awaitable(() => {
    try {
      const conn = rootStore.getSnapshot();
      if (isConnection(conn)) {
        return insert(conn, cacheEntryStore, input, cacheKey);
      } else {
        return noopBreakable;
      }
    } catch (err) {
      if (err instanceof Promise) {
        return err.then(getBreakable);
      }
      throw err;
    }
  });
  const breaker = new Breaker(() => {
    let connected = true;
    let prevConn = noopBreakable;
    getBreakable().then((conn) => {
      if (connected) {
        conn.connect();
      }
      prevConn = conn;
    });
    const unsubscribe = rootStore.subscribe(() => {
      getBreakable().then((nextConn) => {
        if (nextConn !== prevConn) {
          prevConn.disconnect();
          prevConn = nextConn;
          if (connected) {
            nextConn.connect();
          }
        }
      });
    });
    return () => {
      connected = false;
      prevConn.disconnect();
      unsubscribe();
    };
  });
  let currentSubscribers = 0;
  const connectionStoreFactory = /* @__PURE__ */ __name((refinedFocus) => {
    const store = storeFactory(refinedFocus);
    return {
      ...store,
      subscribe(listener) {
        const unsubscribe = store.subscribe(listener);
        currentSubscribers += 1;
        breaker.connect();
        return () => {
          unsubscribe();
          currentSubscribers = Math.max(currentSubscribers - 1, 0);
          if (currentSubscribers <= 0) {
            breaker.disconnect();
          }
        };
      }
    };
  }, "connectionStoreFactory");
  return [connectionStoreFactory, cacheKeyFocus];
}, "createConnectionStoreFactory");

// src/proxy-lens.ts
var THROW_ON_COPY = Symbol();
var specialKeys = ["use", "getStore", "$key"];
var functionTrapKeys = ["arguments", "caller", "prototype"];
var proxyLens = /* @__PURE__ */ __name((storeFactory, focus) => {
  let keyCache;
  let connectionCache;
  let $key;
  let use;
  let getStore;
  const proxy = new Proxy(function() {
  }, {
    apply(_target, _thisArg, argsArray) {
      const connCache = connectionCache ?? (connectionCache = {});
      const [input] = argsArray;
      const cacheKey = JSON.stringify(input);
      let next = connCache[cacheKey];
      if (!next) {
        const [nextFactory, nextFocus] = createConnectionStoreFactory(storeFactory, focus, input);
        next = connCache[cacheKey] = proxyLens(nextFactory, nextFocus);
      }
      return next;
    },
    get(_target, key) {
      if (key === "$$typeof") {
        return void 0;
      }
      if (key === "$key") {
        $key ?? ($key = keyPathToString(focus.keyPath));
        return $key;
      }
      if (key === "use") {
        use ?? (use = createUseLens(proxy));
        return use;
      }
      if (key === "getStore") {
        getStore ?? (getStore = () => storeFactory(focus));
        return getStore;
      }
      keyCache ?? (keyCache = {});
      if (keyCache[key] === void 0) {
        const nextFocus = refineLensFocus(focus, [key]);
        const nextProxy = proxyLens(storeFactory, nextFocus);
        keyCache[key] = nextProxy;
      }
      return keyCache[key];
    },
    ownKeys(_target) {
      return [...specialKeys, ...functionTrapKeys, THROW_ON_COPY];
    },
    has(_target, key) {
      return specialKeys.includes(key);
    },
    getOwnPropertyDescriptor(target, key) {
      if (specialKeys.includes(key)) {
        return {
          configurable: true,
          enumerable: true,
          writable: false,
          value: proxy[key]
        };
      }
      if (functionTrapKeys.includes(key)) {
        return Reflect.getOwnPropertyDescriptor(target, key);
      }
      if (ReactDevtools.isCalledInsideReactDevtools()) {
        return {
          configurable: true,
          enumerable: false,
          value: void 0
        };
      }
      throw new Error("ProxyLens threw because you tried to access all property descriptors\u2014probably through `{ ...lens }` or `Object.assign({}, lens)`. Doing this will break the type safety offered by this library so it is forbidden. Sorry, buddy pal.");
    },
    getPrototypeOf() {
      return null;
    },
    preventExtensions() {
      return true;
    },
    isExtensible() {
      return false;
    },
    set() {
      throw new Error("Cannot set property on ProxyLens");
    },
    deleteProperty() {
      throw new Error("Cannot delete property on ProxyLens");
    }
  });
  return proxy;
}, "proxyLens");

// src/create-lens.ts
var createLens = /* @__PURE__ */ __name((initialState) => {
  const [factory, focus] = createRootStoreFactory(initialState);
  return proxyLens(factory, focus);
}, "createLens");
export {
  connection,
  createLens,
  useCreateLens
};
//# sourceMappingURL=index.mjs.map