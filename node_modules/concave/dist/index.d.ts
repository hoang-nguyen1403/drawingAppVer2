declare type AnyObject = {
    [key: string | number | symbol]: any;
};
declare type AnyArray = any[];
declare type AnyPrimitive = number | bigint | string | boolean | null | void | symbol;
declare type AnyConnection = Connection<any, any>;
declare type Listener = () => void;
declare type Unsubscribe = () => void;
declare type Updater<A> = (a: A) => A;
declare type Update<A> = (updater: Updater<A>) => void;

declare type Store<A> = {
    getSnapshot(): A;
    setSnapshot(next: A): boolean;
    subscribe(onStoreChange?: Listener): Unsubscribe;
};

interface Breakable {
    connect(): void;
    disconnect(): void;
}

declare class SuspendedClosure<A> implements Breakable {
    private resolution;
    private breaker;
    private onReady;
    private ready;
    constructor();
    getSnapshot(): A;
    setSnapshot(value: A): void;
    /**
     * Connect the entry to the store by passing a subscribe function. Only
     * allow this in transitioning from unresolved to resolved.
     */
    load(subscribe: () => Unsubscribe): void;
    connect(): void;
    disconnect(): void;
}

declare type ValueCache<A> = {
    [cacheKey: string]: A;
};
declare type InsertConnection<A, I> = (store: Store<A>, input: I, cacheKey: string) => SuspendedClosure<A>;
declare const INSERT: unique symbol;
declare const CACHE: unique symbol;
declare type Connection<A, I = void> = {
    [INSERT]: InsertConnection<A, I>;
    [CACHE]: ValueCache<A>;
};
declare const connection: <A, I = void>(create: (store: Store<A>, input: I) => Unsubscribe | void) => Connection<A, I>;

declare type BaseProxyValue<A> = {
    toJSON(): A;
    toLens(): ProxyLens<A>;
};
declare type ArrayProxyValue<A extends AnyArray> = BaseProxyValue<A> & Array<ProxyValue<A[number]>>;
declare type ObjectProxyValue<A extends AnyObject> = BaseProxyValue<A> & {
    [K in keyof A]: ProxyValue<A[K]>;
};
declare type ProxyValue<A> = A extends AnyArray ? ArrayProxyValue<A> : A extends AnyObject ? ObjectProxyValue<A> : A extends AnyPrimitive ? A : never;

declare type ShouldUpdateBoolean = boolean;
declare type ShouldUpdateArray<A> = (keyof A)[];
declare type ShouldUpdateObject<A> = {
    [K in keyof A]?: A[K] extends any[] ? ShouldUpdate<A[K][number]> : ShouldUpdate<A[K]>;
};
declare type ShouldUpdateFunction<A> = (prev: A, next: A) => boolean;
declare type ShouldUpdate<A> = ShouldUpdateBoolean | ShouldUpdateFunction<A> | ShouldUpdateArray<A> | ShouldUpdateObject<A>;

declare type BaseProxyLens<A> = {
    /**
     * Fetches the store for current focus.
     */
    getStore(): Store<A>;
    /**
     * Collapses the lens into a React hook.
     */
    use(shouldUpdate?: ShouldUpdate<A>): [ProxyValue<A>, Update<A>];
    /**
     * A unique key for cases when you need a key. e.g. A React list.
     *
     * @example
     * const [list] = useLens(state);
     *
     * list.map(value => {
     *   const lens = value.toLens();
     *
     *   return <ListItem key={lens.$key} state={lens} />;
     * });
     */
    $key: string;
};
declare type ConnectionProxyLens<A> = BaseProxyLens<A> & (A extends Connection<infer B, infer I> ? (input: I) => ProxyLens<B> : {});
declare type ArrayProxyLens<A extends AnyArray> = BaseProxyLens<A> & {
    [K in number]: ProxyLens<A[K]>;
};
declare type ObjectProxyLens<A extends AnyObject> = BaseProxyLens<A> & {
    [K in keyof A]: ProxyLens<A[K]>;
};
declare type PrimitiveProxyLens<A extends AnyPrimitive> = BaseProxyLens<A>;
declare type ProxyLens<A> = A extends AnyConnection ? ConnectionProxyLens<A> : A extends AnyObject ? ObjectProxyLens<A> : A extends AnyArray ? ArrayProxyLens<A> : A extends AnyPrimitive ? PrimitiveProxyLens<A> : never;

declare const createLens: <S>(initialState: S) => ProxyLens<S>;

declare function useCreateLens<S>(initialState: S | (() => S)): ProxyLens<S>;

declare type Lens<A> = ProxyLens<A>;

export { Connection, Lens, Store, connection, createLens, useCreateLens };
